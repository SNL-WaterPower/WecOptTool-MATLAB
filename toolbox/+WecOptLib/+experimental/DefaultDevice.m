classdef DefaultDevice < WecOptLib.experimental.base.Device
    % Class representing a device with a given geometry and contoller
    % configuration. DefaultDevice objects should only be created using the
    % ``makeDevice`` method of the 
    % :mat:class:`+WecOptLib.+experimental.DefaultBlueprint` class.
    %
    % Attributes:
    %     hydro (:mat:class:`+WecOptLib.+experimental.types.Hydro`):
    %         The Hydro object assosiated to this device geometry
    %     motions (array of :mat:class:`+WecOptLib.+experimental.types.Motion`):
    %         The Motion objects generated by the last call of `simulate`,
    %         per sea state. Empty by default.
    %     performances (array of :mat:class:`+WecOptLib.+experimental.types.Performance`)
    %         The Performance objects generated by the last call of 
    %         `simulate`, per sea state. Empty by default.
    %     aggregation (optional)
    %         If the Blueprint.aggregationHook property is defined, the
    %         result of that function is added here.
    %
    
    % Copyright 2020 National Technology & Engineering Solutions of Sandia, 
    % LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the 
    % U.S. Government retains certain rights in this software.
    %
    % This file is part of WecOptTool.
    % 
    %     WecOptTool is free software: you can redistribute it and/or 
    %     modify it under the terms of the GNU General Public License as 
    %     published by the Free Software Foundation, either version 3 of 
    %     the License, or (at your option) any later version.
    % 
    %     WecOptTool is distributed in the hope that it will be useful,
    %     but WITHOUT ANY WARRANTY; without even the implied warranty of
    %     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    %     GNU General Public License for more details.
    % 
    %     You should have received a copy of the GNU General Public 
    %     License along with WecOptTool.  If not, see 
    %     <https://www.gnu.org/licenses/>. 
    
    properties (Access = private)
        staticMotion
        dynamicModelCB
        controllerCB
        aggregationCB
    end
    
    methods (Access = {?WecOptLib.experimental.DefaultBlueprint})
        
        function obj = DefaultDevice(hydro,                 ...
                                     staticModelCallback,   ...
                                     dynamicModelCallback,  ...
                                     controllerCallbBack,   ...
                                     aggregationCB)
                          
            obj.hydro = hydro;
            obj.staticMotion = staticModelCallback(hydro);
            obj.dynamicModelCB = dynamicModelCallback;
            obj.controllerCB = controllerCallbBack;
            obj.aggregationCB = aggregationCB;
            
        end
        
    end
    
    methods
        
        function simulate(obj, seaState)
            % Determine the performace of the WEC device
            %
            % Arguments:
            %     seaState (:mat:class:`+WecOptLib.+experimental.types.SeaState`):
            %         The sea-state(s) to be simulated
            %
            
            if ~isa(seaState, "WecOptLib.experimental.types.SeaState")
                errStr = "simulate only accepts SeaState objects";
                error("WecOptTool:Device:NotSeaState", errStr)
            end
            
            NSS = length(seaState);
            
            mymotions(1:NSS) =  WecOptLib.experimental.types.Motion();
            myperformances(1:NSS) =   ...
                                WecOptLib.experimental.types.Performance();
            
            for iSS = 1:NSS
                
                S = seaState(iSS);
                
                smotion = obj.dynamicModelCB(obj.staticMotion, ...
                                             obj.hydro,        ...
                                             S);

                if ~isa(smotion, "WecOptLib.experimental.types.Motion")
                    errStr = "The dynamic model must return a " +   ...
                             "Motion object";
                    error("WecOptTool:Device:NotMotion", errStr)
                end

                sperformance = obj.controllerCB(smotion, S);
                
                if ~isa(sperformance,   ...
                        "WecOptLib.experimental.types.Performance")
                    
                    errStr = "Controllers must return a " +   ...
                             "Performance object";
                    error("WecOptTool:Device:NotPerformance", errStr)
                    
                end
                
                mymotions(iSS) = smotion;
                myperformances(iSS) = sperformance;
                
            end
            
            obj.motions = mymotions;
            obj.performances = myperformances;
            
            % Run the aggregation hook if given
            if ~isempty(obj.aggregationCB)
                obj.aggregation = obj.aggregationCB(seaState,       ...
                                                    obj.hydro,      ...
                                                    obj.motions,    ...
                                                    obj.performances);
            end
           
        end
    
    end
    
end
